// Generated by `wit-bindgen-wrpc-go` 0.1.0. DO NOT EDIT!
package atomics

import (
	bytes "bytes"
	context "context"
	binary "encoding/binary"
	errors "errors"
	fmt "fmt"
	exports__wrpc__keyvalue__store "github.com/couchbase-examples/wasmcloud-provider-couchbase/bindings/exports/wrpc/keyvalue/store"
	wrpc "github.com/wrpc/wrpc/go"
	io "io"
	slog "log/slog"
	utf8 "unicode/utf8"
)

type Error = exports__wrpc__keyvalue__store.Error
type Handler interface {
	// Atomically increment the value associated with the key in the store by the given delta. It
	// returns the new value.
	//
	// If the key does not exist in the store, it creates a new key-value pair with the value set
	// to the given delta.
	//
	// If any other error occurs, it returns an `Err(error)`.
	Increment(ctx__ context.Context, bucket string, key string, delta uint64) (r0__ *wrpc.Result[uint64, Error], err__ error)
}

func ServeInterface(c wrpc.Client, h Handler) (stop func() error, err error) {
	stops := make([]func() error, 0, 1)
	stop = func() error {
		for _, stop := range stops {
			if err := stop(); err != nil {
				return err
			}
		}
		return nil
	}
	stop0, err := c.Serve("wrpc:keyvalue/atomics@0.2.0-draft", "increment", func(ctx context.Context, buffer []byte, tx wrpc.Transmitter, inv wrpc.IncomingInvocation) error {
		slog.DebugContext(ctx, "subscribing for `wrpc:keyvalue/atomics@0.2.0-draft.increment` parameters")

		payload := make(chan []byte)
		stop, err := inv.Subscribe(func(ctx context.Context, buf []byte) {
			payload <- buf
		})
		if err != nil {
			return err
		}
		defer func() {
			if err := stop(); err != nil {
				slog.ErrorContext(ctx, "failed to stop parameter subscription", "err", err)
			}
		}()

		// TODO: Handle async parameters

		slog.DebugContext(ctx, "accepting handshake")
		if err := inv.Accept(ctx, nil); err != nil {
			return fmt.Errorf("failed to complete handshake: %w", err)
		}
		r := wrpc.NewChanReader(ctx, payload, buffer)
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func(r wrpc.ByteReader) (string, error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading string length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read string length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading string bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read string bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return string(buf), errors.New("string is not valid UTF-8")
					}
					return string(buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("string length overflows a 32-bit integer")
		}(r)
		if err != nil {
			return fmt.Errorf("failed to read parameter 0")
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func(r wrpc.ByteReader) (string, error) {
			var x uint32
			var s uint
			for i := 0; i < 5; i++ {
				slog.Debug("reading string length byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return "", fmt.Errorf("failed to read string length byte: %w", err)
				}
				if b < 0x80 {
					if i == 4 && b > 1 {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					x = x | uint32(b)<<s
					buf := make([]byte, x)
					slog.Debug("reading string bytes", "len", x)
					_, err = r.Read(buf)
					if err != nil {
						return "", fmt.Errorf("failed to read string bytes: %w", err)
					}
					if !utf8.Valid(buf) {
						return string(buf), errors.New("string is not valid UTF-8")
					}
					return string(buf), nil
				}
				x |= uint32(b&0x7f) << s
				s += 7
			}
			return "", errors.New("string length overflows a 32-bit integer")
		}(r)
		if err != nil {
			return fmt.Errorf("failed to read parameter 1")
		}
		slog.DebugContext(ctx, "reading parameter", "i", 2)
		p2, err := func(r wrpc.ByteReader) (uint64, error) {
			var x uint64
			var s uint
			for i := 0; i < 10; i++ {
				slog.Debug("reading `uint64` byte", "i", i)
				b, err := r.ReadByte()
				if err != nil {
					if i > 0 && err == io.EOF {
						err = io.ErrUnexpectedEOF
					}
					return x, fmt.Errorf("failed to read `uint64` byte: %w", err)
				}
				if b < 0x80 {
					if i == 9 && b > 1 {
						return x, errors.New("varint overflows a 64-bit integer")
					}
					return x | uint64(b)<<s, nil
				}
				x |= uint64(b&0x7f) << s
				s += 7
			}
			return x, errors.New("varint overflows a 64-bit integer")
		}(r)
		if err != nil {
			return fmt.Errorf("failed to read parameter 2")
		}
		slog.DebugContext(ctx, "calling `wrpc:keyvalue/atomics@0.2.0-draft.increment` handler")
		r0, err := h.Increment(ctx, p0, p1, p2)
		if err != nil {
			return fmt.Errorf("failed to handle `wrpc:keyvalue/atomics@0.2.0-draft.increment` invocation: %w", err)
		}
		var buf bytes.Buffer
		if err := func(v *wrpc.Result[uint64, Error], w wrpc.ByteWriter) error {
			switch {
			case v.Ok == nil && v.Err == nil:
				return errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				if err := func(v uint64, w wrpc.ByteWriter) error {
					b := make([]byte, binary.MaxVarintLen64)
					i := binary.PutUvarint(b, uint64(v))
					slog.Debug("writing u64")
					_, err := w.Write(b[:i])
					return err
				}(*v.Ok, w); err != nil {
					return fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				return nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				if err := (*v.Err).WriteTo(w); err != nil {
					return fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				return nil
			}
		}(r0, &buf); err != nil {
			return fmt.Errorf("failed to write result value 0: %w", err)
		}
		slog.DebugContext(ctx, "transmitting `wrpc:keyvalue/atomics@0.2.0-draft.increment` result")
		if err := tx.Transmit(context.Background(), buf.Bytes()); err != nil {
			return fmt.Errorf("failed to transmit result: %w", err)
		}
		return nil
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wrpc:keyvalue/atomics@0.2.0-draft.increment`: %w", err)
	}
	stops = append(stops, stop0)
	return stop, nil
}
